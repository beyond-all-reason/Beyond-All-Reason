	#define TA			// This is a TA script

#include "sfxtype.h"
#include "exptype.h"

piece chassis, backTracks, lTrack, plateFrontLeft, plateMidLeft, plateRearLeft, plateFrontRight, plateMidRight, plateRearRight, rTrack, 
sleeve1, barrel1, flare1,
sleeve2, barrel2, flare2,
sleeve3, barrel3, flare3,
sleeve4, barrel4, flare4,
sleeve5, barrel5, flare5,
sleeve6, barrel6, flare6,
trackingTower, trackingHeadingPivot, trackingTurret, targetFlare;

static-var  weapon, restore_delay, target, lastHeading, lastPitch, justFired, opened, newTargetID, oldTargetID, burstDelay, timeout, volleyCount, 
canShoot, stage, ready, newLosState, oldLosState, missilesFired, newHealth, oldHealth, newExtraMissile, oldExtraMissile, newArmored, oldArmored;

// Signal definitions
#define SIG_AIM				2
#define SIG_OPEN			4
#define SIG_AIM_2			8
#define SIG_AIM_3			16
#define SIG_AIM_4			32
#define SIG_AIM_5			64
#define SIG_AIM_6			128
#define SIG_AIM_7			256
#define SIG_TIMER			512
#define SIG_RESTORE			1024

#define BASEPIECE chassis
#define HITSPEED <55.0>
//how 'heavy' the unit is, on a scale of 1-10
#define UNITSIZE 5
#define MAXTILT 100

lua_ShotCounter()
{
	return(0);
}

Timer()
{
	Signal SIG_TIMER;
	set-signal-mask SIG_TIMER;
	sleep 3500;
	timeout = 0;
}

CloseTimer()
{
	signal SIG_OPEN;
	start-script Close();
	sleep restore_delay - 4000;
	justFired = justFired - 1;
}

shotCounter(counter, targetID, burstrate, health, losstate, damage, armored)
{
	//get PRINT(counter, canShoot, newArmored, oldArmored);
	oldHealth = newHealth;
	newHealth = health;
	burstDelay = burstrate;
	oldTargetID = newTargetID;
	newTargetID = targetID;
	oldLosState = newLosState;
	newLosState = losstate;
	oldArmored = newArmored;
	newArmored = armored;
	
	if(newTargetID == oldTargetID)
	{
		if(NOT (newLosState == oldLosState))									//LOS state changed
		{
			canShoot = counter - missilesFired;									//Switches to new missile count. If some missiles were fired needs to shoot less missiles
			oldHealth = newHealth;												//Prevents bug: When out of LOS but in radar the health return is 0, so when unit enters LOS it triggers the repair script and fires additional missiles
			if(canShoot < 0)													//Prevents a bug that launches all missiles instantly
			{
				canShoot = 0;
			}
		}
		
		if(NOT (newArmored == oldArmored))										//Armored state changed
		{
			canShoot = counter - missilesFired;									//Switches to new missile count. If some missiles were fired needs to shoot less missiles
			if(canShoot < 0)													//Prevents a bug that launches all missiles instantly
			{
				canShoot = 0;
			}
		}
		
		if(newHealth > oldHealth)												//Target is being repaired
		{
			if(missilesFired == 0)												//If being repaired reset missile count until ready to fire
			{
				canShoot = counter;
			}
			else
			{
				if(newExtraMissile > oldExtraMissile)								//Only when an extra missile is needed
				{
					oldExtraMissile = newExtraMissile;
				}
				if(oldExtraMissile < 1)												//For first extra missile check how much health is needed to next damage treshold
				{
					if((((newHealth - oldHealth) / (((damage - (newHealth % damage)) / 20) + 1)) - 0.5) >= 1)		//checks if the current repair will get it to the next damage treshold before the missiles hit. +1 prevents division by 0 error
					{
						newExtraMissile = 1;
					}
				}
				else
				{
					newExtraMissile = (((newHealth - oldHealth) / 15));		//If the change is greater than 500 over 3.5s fire an extra missile. 2 extra for 1000 etc
				}
				if(newExtraMissile > oldExtraMissile)								//Only when an additional extra missile is needed
				{
					canShoot = canShoot + newExtraMissile - oldExtraMissile;
				}
			}
		}
		if(timeout == 1)														//Prevents same target refresh until missiles hit it
		{
			return(0);
		}
		
	}
	oldHealth = health;															//If new target reset old data
	oldTargetID = targetID;
	oldLosState = losstate;
	oldArmored = armored;
	missilesFired = 0;
	newExtraMissile = 0;
	oldExtraMissile = 0;
	canShoot = counter;
	return(0);
}

Create()
{
	hide flare1;
	hide flare2;
	hide flare3;
	hide flare4;
	hide flare5;
	hide flare6;
	hide targetFlare;

	move lTrack to x-axis [0.3] now;
	move rTrack to x-axis [-0.3] now;

	move barrel6 to y-axis [-6] now;
	move sleeve6 to y-axis [-1.7] now;
	move barrel5 to y-axis [-6] now;
	move sleeve5 to y-axis [-1.7] now;
	move barrel4 to y-axis [-6] now;
	move sleeve4 to y-axis [-1.7] now;
	move barrel3 to y-axis [-6] now;
	move sleeve3 to y-axis [-1.7] now;
	move barrel2 to y-axis [-6] now;
	move sleeve2 to y-axis [-1.7] now;
	move barrel1 to y-axis [-6] now;
	move sleeve1 to y-axis [-2.8] now;
	turn plateRearRight to z-axis <30> now;
	turn plateMidRight to z-axis <30> now;
	turn plateFrontRight to z-axis <30> now;
	turn plateRearLeft to z-axis <-30> now;
	turn plateMidLeft to z-axis <-30> now;
	turn plateFrontLeft to z-axis <-30> now;
	move plateFrontLeft to z-axis [-1] now;
	move plateRearLeft to z-axis [1] now;
	move plateFrontRight to z-axis [-1] now;
	move plateRearRight to z-axis [1] now;

	stage = 4;
	ready = 0;
	weapon = 0;
	justFired = 0;
	return (0);
}

SetMaxReloadTime(Func_Var_1)
{
	restore_delay = Func_Var_1;
	return (0);
}

static-var  Stunned;
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	turn trackingHeadingPivot to y-axis <0> speed <250.000000>;
	weapon = 0;
}
SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
	}
}
RestoreAfterDelay()
{
	signal SIG_RESTORE;
	set-signal-mask SIG_RESTORE;
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}

Close()
{	
	opened = 0;
	set-signal-mask SIG_OPEN;
	sleep 1000;
	ready = 0;
	stage = 1;
	move barrel1 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve1 to y-axis [-2.8] speed [5.6];
	turn sleeve1 to x-axis <10> speed <25>;
	move barrel2 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve2 to y-axis [-1.7] speed [3.4];
	move barrel3 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve3 to y-axis [-1.7] speed [3.4];
	move barrel4 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve4 to y-axis [-1.7] speed [3.4];
	move barrel5 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve5 to y-axis [-1.7] speed [3.4];
	move barrel6 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve6 to y-axis [-1.7] speed [3.4];
	sleep 100;
	stage = 2;
	turn plateFrontLeft to z-axis <-30> speed <30>;
	sleep 200;
	turn plateMidLeft to z-axis <-30> speed <30>;
	sleep 200;
	turn plateRearLeft to z-axis <-30> speed <30>;
	sleep 200;
	stage = 3;
	turn plateFrontRight to z-axis <30> speed <30>;
	sleep 200;
	turn plateMidRight to z-axis <30> speed <30>;
	sleep 200;
	turn plateRearRight to z-axis <30> speed <30>;
	wait-for-turn plateRearRight around z-axis;
	stage = 4;
	move plateFrontLeft to z-axis [-1] speed [4];
	sleep 50;
	move plateRearLeft to z-axis [1] speed [4];
	sleep 50;
	move plateFrontRight to z-axis [-1] speed [4];
	sleep 50;
	move plateRearRight to z-axis [1] speed [4];
}

Open()
{
	if(justFired == volleyCount)									//Prevents opening if no launcher can shoot, so the hatches close for the reload
	{
		return (0);
	}
	signal SIG_OPEN;
	opened = 1;
	if (stage == 4)													//Stages check how far it closed before interrupted so it opens back up faster
	{
		move plateFrontLeft to z-axis [0] speed [4];
		sleep 50;
		move plateRearLeft to z-axis [0] speed [4];
		sleep 50;
		move plateFrontRight to z-axis [0] speed [4];
		sleep 50;
		move plateRearRight to z-axis [0] speed [4];
		wait-for-move plateRearRight along z-axis;
		stage = 3;
	}
	if (stage == 3)
	{
		turn plateRearRight to z-axis <0> speed <30>;
		sleep 200;
		turn plateMidRight to z-axis <0> speed <30>;
		sleep 200;
		turn plateFrontRight to z-axis <0> speed <30>;
		sleep 200;
		stage = 2;
	}
	if (stage == 2)
	{
		turn plateRearLeft to z-axis <0> speed <30>;
		sleep 200;
		turn plateMidLeft to z-axis <0> speed <30>;
		sleep 200;
		turn plateFrontLeft to z-axis <0> speed <30>;
		sleep 100;
		stage = 1;
	}
	if (stage == 1)
	{
		move sleeve6 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel6 to y-axis [0] speed [12];
		move sleeve5 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel5 to y-axis [0] speed [12];
		move sleeve4 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel4 to y-axis [0] speed [12];
		move sleeve3 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel3 to y-axis [0] speed [12];
		move sleeve2 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel2 to y-axis [0] speed [12];
		turn sleeve1 to x-axis <0> speed <25>;
		move sleeve1 to y-axis [0] speed [5.6];
		sleep 100;
		move barrel1 to y-axis [0] speed [12];
		stage = 0;
	}
	ready = 1;
	set-signal-mask SIG_OPEN;
	sleep 1000;
	start-script Close();
}

AimWeapon1(heading, pitch)												//Beamer script
{
	signal SIG_AIM;
	set-signal-mask SIG_AIM;
	
	
		
	turn trackingHeadingPivot to y-axis heading speed <500.000000>;
	//turn gun to x-axis <0.000000> - pitch speed <250.000000>;
	// if the turret can turn to its new heading in one frame, just return true and do not wait for turn
	if ( ( get ABS ( lastHeading - heading ) < 3000 ) AND ( get ABS ( lastPitch - pitch ) < 1500 ) )
	{
		lastHeading = heading;
		lastPitch = pitch;
		return (1);
	}
	// if turret needs more than one frame to turn to new heading, wait for the turn
	// seems to take 3 frames for wait-for-turn to process
	wait-for-turn trackingHeadingPivot around y-axis;
	//wait-for-turn gun around x-axis;
	// after waiting for the turn, set the lastHeading and lastPitch variables
	lastHeading = heading;
	lastPitch = pitch;
	return (1);
}

AimFromWeapon1(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon1()														//Sets target to 1 and just as the laser shot ends sets it to 0, so the next shot sets it to 1 the next milisecond, so its 1 whenever the laser is firing and 0 when it isn't
{
	target = 1;
	sleep 99;
	target = 0;
}

QueryWeapon1(piecenum)
{
	piecenum = targetFlare;
}

AimWeapon2(heading, pitch)
{
	var weaponNum;
	volleyCount = 6;
	weaponNum = 2;
	call-script lua_ShotCounter(volleyCount, weaponNum);
	
	Signal SIG_AIM_2;
	
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	
	while(canShoot > 0 AND NOT (weapon == 0))						//Waits for its turn and terminates loops once no more shots are available
	{
		sleep 1;
	}
	set-signal-mask SIG_AIM_2;										//Prevents a bug where it can shoot the first missile while still closed
	if(canShoot == 0)												//Checks if shots are available
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	return (1);
}

AimFromWeapon2(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon2()
{
	timeout = 1;
	justFired = justFired + 1;										//Used to delay next opening of hatches, so they close between shots
	canShoot = canShoot - 1;
	start-script Timer();
	start-script CloseTimer();
	start-script RestoreAfterDelay();
	missilesFired = missilesFired + 1;
	sleep (burstDelay - 80);
	weapon = (weapon + 1) % volleyCount;
}

QueryWeapon2(piecenum)
{
	piecenum = flare6;
	return (0);
}

AimWeapon3(heading, pitch)
{
	Signal SIG_AIM_3;
	
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	
	while(canShoot > 0 AND NOT (weapon == 1))						//Waits for its turn
	{
		sleep 1;
	}
	set-signal-mask SIG_AIM_3;										//Prevents a bug where it can shoot the first missile while still closed
	if(canShoot == 0)												//Checks if shots are available
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	return (1);
}

AimFromWeapon3(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon3()
{
	timeout = 1;
	justFired = justFired + 1;										//Used to delay next opening of hatches, so they close between shots
	canShoot = canShoot - 1;
	start-script Timer();
	start-script CloseTimer();
	start-script RestoreAfterDelay();
	missilesFired = missilesFired + 1;
	sleep (burstDelay - 80);
	weapon = (weapon + 1) % volleyCount;
}

QueryWeapon3(piecenum)
{
	piecenum = flare5;
	return (0);
}

AimWeapon4(heading, pitch)
{
	Signal SIG_AIM_4;
	
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	
	while(canShoot > 0 AND NOT (weapon == 2))						//Waits for its turn
	{
		sleep 1;
	}
	set-signal-mask SIG_AIM_4;										//Prevents a bug where it can shoot the first missile while still closed
	if(canShoot == 0)												//Checks if shots are available
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	return (1);
}

AimFromWeapon4(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon4()
{
	timeout = 1;
	justFired = justFired + 1;										//Used to delay next opening of hatches, so they close between shots
	canShoot = canShoot - 1;
	start-script Timer();
	start-script CloseTimer();
	start-script RestoreAfterDelay();
	missilesFired = missilesFired + 1;
	sleep (burstDelay - 80);
	weapon = (weapon + 1) % volleyCount;
}

QueryWeapon4(piecenum)
{
	piecenum = flare4;
	return (0);
}

AimWeapon5(heading, pitch)
{
	Signal SIG_AIM_5;
	
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	
	while(canShoot > 0 AND NOT (weapon == 3))						//Waits for its turn
	{
		sleep 1;
	}
	set-signal-mask SIG_AIM_5;										//Prevents a bug where it can shoot the first missile while still closed
	if(canShoot == 0)												//Checks if shots are available
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	return (1);
}

AimFromWeapon5(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon5()
{
	timeout = 1;
	justFired = justFired + 1;										//Used to delay next opening of hatches, so they close between shots
	canShoot = canShoot - 1;
	start-script Timer();
	start-script CloseTimer();
	start-script RestoreAfterDelay();
	missilesFired = missilesFired + 1;
	sleep (burstDelay - 80);
	weapon = (weapon + 1) % volleyCount;
}

QueryWeapon5(piecenum)
{
	piecenum = flare3;
	return (0);
}

AimWeapon6(heading, pitch)
{
	Signal SIG_AIM_6;
	
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	
	while(canShoot > 0 AND NOT (weapon == 4))						//Waits for its turn
	{
		sleep 1;
	}
	set-signal-mask SIG_AIM_6;										//Prevents a bug where it can shoot the first missile while still closed
	if(canShoot == 0)												//Checks if shots are available
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	return (1);
}

AimFromWeapon6(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon6()
{
	timeout = 1;
	justFired = justFired + 1;										//Used to delay next opening of hatches, so they close between shots
	canShoot = canShoot - 1;
	start-script Timer();
	start-script CloseTimer();
	start-script RestoreAfterDelay();
	missilesFired = missilesFired + 1;
	sleep (burstDelay - 80);
	weapon = (weapon + 1) % volleyCount;
}

QueryWeapon6(piecenum)
{
	piecenum = flare2;
	return (0);
}

AimWeapon7(heading, pitch)
{
	Signal SIG_AIM_7;
	
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	
	while(canShoot > 0 AND NOT (weapon == 5))						//Waits for its turn
	{
		sleep 1;
	}
	set-signal-mask SIG_AIM_7;										//Prevents a bug where it can shoot the first missile while still closed
	if(canShoot == 0)												//Checks if shots are available
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	return (1);
}

AimFromWeapon7(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon7()
{
	timeout = 1;
	justFired = justFired + 1;										//Used to delay next opening of hatches, so they close between shots
	canShoot = canShoot - 1;
	start-script Timer();
	start-script CloseTimer();
	start-script RestoreAfterDelay();
	missilesFired = missilesFired + 1;
	sleep (burstDelay - 80);
	weapon = (weapon + 1) % volleyCount;
}

QueryWeapon7(piecenum)
{
	piecenum = flare1;
	return (0);
}

SweetSpot(piecenum)
{
	piecenum = chassis;
}

Killed(severity, corpsetype)
{
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type BITMAPONLY | NOHEATCLOUD;
		//explode flare2 type BITMAPONLY | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode backTracks type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type FALL | NOHEATCLOUD;
		//explode flare2 type FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type SMOKE | FALL | NOHEATCLOUD;
		explode backTracks type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		//explode flare2 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		explode backTracks type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		//explode flare2 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
