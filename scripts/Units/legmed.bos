	#define TA			// This is a TA script

#include "sfxtype.h"
#include "exptype.h"

piece chassis, backTracks, lTrack, plateFrontLeft, plateMidLeft, plateRearLeft, plateFrontRight, plateMidRight, plateRearRight, rTrack, 
sleeve1, barrel1, flare1,
sleeve2, barrel2, flare2,
sleeve3, barrel3, flare3,
sleeve4, barrel4, flare4,
sleeve5, barrel5, flare5,
sleeve6, barrel6, flare6,
trackingTower, trackingHeadingPivot, trackingTurret, targetFlare;

static-var  weapon, restore_delay, target, lastheading, lastpitch, justfired1, justfired2, justfired3, justfired4, justfired5, justfired6, shot, opened, moving, counter, status, targetID, targetID1, targetID2, burstrate, burstrate2, 
canshoot, stage1, stage2, stage3, stage4, ready, losstate, losstate1, losstate2, canshoot1, missilesfired, health1, health2, healthdiff, extramissile, extramissile1, timeout;

// Signal definitions
#define SIG_AIM				2
#define SIG_OPEN			4
#define SIG_AIM_2			8
#define SIG_AIM_3			16
#define SIG_AIM_4			32
#define SIG_AIM_5			64
#define SIG_AIM_6			128
#define SIG_AIM_7			256
#define SIG_TIMER			512

#define BASEPIECE chassis
#define HITSPEED <55.0>
//how 'heavy' the unit is, on a scale of 1-10
#define UNITSIZE 5
#define MAXTILT 100

lua_missile_counter() 
{
	return(0);
}

Timer()
{
	Signal SIG_TIMER;
	set-signal-mask SIG_TIMER;
	sleep 4000;
	timeout = 0;
}

missile_counter(status, counter, targetID, burstrate, health, losstate)
{
	health2 = health1;
	health1 = health;
	canshoot1 = counter;
	burstrate2 = burstrate;
	targetID2 = targetID1;
	targetID1 = targetID;
	losstate2 = losstate1;
	losstate1 = losstate;
	
	get PRINT(counter, targetID, health, healthdiff);
	
	if(targetID1 == targetID2)
	{
		while(NOT (losstate1 == losstate2))										//LOS state changed
		{
			canshoot = canshoot1 - missilesfired;								//If some missiles were fired needs to shoot less missiles
		}
		
		if(health1 > health2)													//target is being repaired
		{
			healthdiff = health1 - health2;
			extramissile1 = extramissile;
			extramissile = ((healthdiff / 20) - 0.5);							//if the change is greater than 500 over 4s then fire an extra missile. 2 extra for 1000 etc
			canshoot = canshoot + extramissile - extramissile1;
		}
		if(timeout == 1)
		{
			return(0);
		}
	}
	missilesfired = 0;
	canshoot = counter;
	return(0);
}

StartMoving()
{
	//call-script lua_missile_counter();
}

Create()
{
	hide flare1;
	hide flare2;
	hide flare3;
	hide flare4;
	hide flare5;
	hide flare6;
	hide targetFlare;

	move lTrack to x-axis [0.3] now;
	move rTrack to x-axis [-0.3] now;

	move barrel6 to y-axis [-6] now;
	move sleeve6 to y-axis [-1.7] now;
	move barrel5 to y-axis [-6] now;
	move sleeve5 to y-axis [-1.7] now;
	move barrel4 to y-axis [-6] now;
	move sleeve4 to y-axis [-1.7] now;
	move barrel3 to y-axis [-6] now;
	move sleeve3 to y-axis [-1.7] now;
	move barrel2 to y-axis [-6] now;
	move sleeve2 to y-axis [-1.7] now;
	move barrel1 to y-axis [-6] now;
	move sleeve1 to y-axis [-2.8] now;
	turn plateRearRight to z-axis <30> now;
	turn plateMidRight to z-axis <30> now;
	turn plateFrontRight to z-axis <30> now;
	turn plateRearLeft to z-axis <-30> now;
	turn plateMidLeft to z-axis <-30> now;
	turn plateFrontLeft to z-axis <-30> now;
	move plateFrontLeft to z-axis [-1] now;
	move plateRearLeft to z-axis [1] now;
	move plateFrontRight to z-axis [-1] now;
	move plateRearRight to z-axis [1] now;

	restore_delay = 3000;
	stage1 = 1;
	stage2 = 1;
	stage3 = 1;
	stage4 = 1;
	ready = 0;
	weapon = 1;
	counter = 6;
	canshoot = 1;
	return (0);
}

SetMaxReloadTime(Func_Var_1)
{
	restore_delay = Func_Var_1;
	return (0);
}

static-var  Stunned;
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	//set-signal-mask 0;
}
SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
	}
}
RestoreAfterDelay()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}

Close()
{
	ready = 0;
	opened = 0;
	sleep 1000;
	stage4 = 1;
	move barrel1 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve1 to y-axis [-2.8] speed [5.6];
	turn sleeve1 to x-axis <10> speed <25>;
	move barrel2 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve2 to y-axis [-1.7] speed [3.4];
	move barrel3 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve3 to y-axis [-1.7] speed [3.4];
	move barrel4 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve4 to y-axis [-1.7] speed [3.4];
	move barrel5 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve5 to y-axis [-1.7] speed [3.4];
	move barrel6 to y-axis [-6] speed [12];
	sleep 100;
	move sleeve6 to y-axis [-1.7] speed [3.4];
	sleep 100;
	stage3 = 1;
	turn plateFrontLeft to z-axis <-30> speed <30>;
	sleep 200;
	turn plateMidLeft to z-axis <-30> speed <30>;
	sleep 200;
	turn plateRearLeft to z-axis <-30> speed <30>;
	sleep 200;
	stage2 = 1;
	turn plateFrontRight to z-axis <30> speed <30>;
	sleep 200;
	turn plateMidRight to z-axis <30> speed <30>;
	sleep 200;
	turn plateRearRight to z-axis <30> speed <30>;
	wait-for-turn plateRearRight around z-axis;
	stage1 = 1;
	move plateFrontLeft to z-axis [-1] speed [4];
	sleep 50;
	move plateRearLeft to z-axis [1] speed [4];
	sleep 50;
	move plateFrontRight to z-axis [-1] speed [4];
	sleep 50;
	move plateRearRight to z-axis [1] speed [4];
}

Open()
{
	signal SIG_OPEN;
	//set-signal-mask SIG_OPEN;
	if((justfired1 == 1) AND (justfired2 == 1) AND (justfired3 == 1) AND (justfired4 == 1) AND (justfired5 == 1) AND (justfired6 == 1))	//Prevents opening if no launcher can shoot, so the hatches close for the reload
	{
		return (0);
	}
	opened = 1;
	if (stage1 == 1)
	{
		move plateFrontLeft to z-axis [0] speed [4];
		sleep 50;
		move plateRearLeft to z-axis [0] speed [4];
		sleep 50;
		move plateFrontRight to z-axis [0] speed [4];
		sleep 50;
		move plateRearRight to z-axis [0] speed [4];
		wait-for-move plateRearRight along z-axis;
		stage1 = 0;
	}
	if (stage2 == 1)
	{
		turn plateRearRight to z-axis <0> speed <30>;
		sleep 200;
		turn plateMidRight to z-axis <0> speed <30>;
		sleep 200;
		turn plateFrontRight to z-axis <0> speed <30>;
		sleep 200;
		stage2 = 0;
	}
	if (stage3 == 1)
	{
		turn plateRearLeft to z-axis <0> speed <30>;
		sleep 200;
		turn plateMidLeft to z-axis <0> speed <30>;
		sleep 200;
		turn plateFrontLeft to z-axis <0> speed <30>;
		sleep 100;
		stage3 = 0;
	}
	if (stage4 == 1)
	{
		move sleeve6 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel6 to y-axis [0] speed [12];
		move sleeve5 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel5 to y-axis [0] speed [12];
		move sleeve4 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel4 to y-axis [0] speed [12];
		move sleeve3 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel3 to y-axis [0] speed [12];
		move sleeve2 to y-axis [0] speed [3.4];
		sleep 100;
		move barrel2 to y-axis [0] speed [12];
		turn sleeve1 to x-axis <0> speed <25>;
		move sleeve1 to y-axis [0] speed [5.6];
		sleep 100;
		move barrel1 to y-axis [0] speed [12];
		stage4 = 0;
	}
	ready = 1;
	sleep 1200;
	start-script Close();
}

AimWeapon1(heading, pitch)												//Beamer script
{
	signal SIG_AIM;
	set-signal-mask SIG_AIM;
	
	
		
	turn trackingHeadingPivot to y-axis heading speed <500.000000>;
	//turn gun to x-axis <0.000000> - pitch speed <250.000000>;
	// if the turret can turn to its new heading in one frame, just return true and do not wait for turn
	if ( ( get ABS ( lastheading - heading ) < 3000 ) AND ( get ABS ( lastpitch - pitch ) < 1500 ) )
	{
		lastheading = heading;
		lastpitch = pitch;
		return (1);
	}
	// if turret needs more than one frame to turn to new heading, wait for the turn
	// seems to take 3 frames for wait-for-turn to process
	wait-for-turn trackingHeadingPivot around y-axis;
	//wait-for-turn gun around x-axis;
	// after waiting for the turn, set the lastheading and lastpitch variables
	lastheading = heading;
	lastpitch = pitch;
	return (1);
}

AimFromWeapon1(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon1()														//Sets target to 1 and just as the laser shot ends sets it to 0, so the next shot sets it to 1 the next milisecond, so its 1 whenever the laser is firing and 0 when it isn't
{
	target = 1;
	sleep 99;
	target = 0;
}

QueryWeapon1(piecenum)
{
	piecenum = targetFlare;
}

AimWeapon2(heading, pitch)
{

	call-script lua_missile_counter();
	
	
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	if(canshoot == 0)												//Checks if it needs to shoot at a target
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	Signal SIG_AIM_2;
	set-signal-mask SIG_AIM_2;
	while(NOT (weapon == 1))										//Waits for its turn
	{
		sleep 1;
	}
	return (1);
}

AimFromWeapon2(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon2()
{
	timeout = 1;
	justfired1 = 1;													//Used to delay next opening of hatches, so they close between shots
	canshoot = canshoot - 1;
	start-script Timer();
	missilesfired = missilesfired + 1;
	sleep (burstrate2 - 80);
	weapon = 2;
	sleep (8275 - (burstrate2 - 100));
	justfired1 = 0;
}

QueryWeapon2(piecenum)
{
	piecenum = flare6;
	return (0);
}

AimWeapon3(heading, pitch)
{
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	if(canshoot == 0)												//Checks if it needs to shoot at a target
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	Signal SIG_AIM_3;
	set-signal-mask SIG_AIM_3;
	while(NOT (weapon == 2))										//Waits for its turn
	{
		sleep 1;
	}
	return (1);
}

AimFromWeapon3(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon3()
{
	timeout = 1;
	justfired2 = 1;													//Used to delay next opening of hatches, so they close between shots
	canshoot = canshoot - 1;
	start-script Timer();
	missilesfired = missilesfired + 1;
	sleep (burstrate2 - 80);
	weapon = 3;
	sleep (8275 - (burstrate2 - 100));
	justfired2 = 0;
}

QueryWeapon3(piecenum)
{
	piecenum = flare5;
	return (0);
}

AimWeapon4(heading, pitch)
{
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	if(canshoot == 0)												//Checks if it needs to shoot at a target
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	Signal SIG_AIM_4;
	set-signal-mask SIG_AIM_4;
	while(NOT (weapon == 3))										//Waits for its turn
	{
		sleep 1;
	}
	return (1);
}

AimFromWeapon4(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon4()
{
	timeout = 1;
	justfired3 = 1;													//Used to delay next opening of hatches, so they close between shots
	canshoot = canshoot - 1;
	start-script Timer();
	missilesfired = missilesfired + 1;
	sleep (burstrate2 - 80);
	weapon = 4;
	sleep (8275 - (burstrate2 - 100));
	justfired3 = 0;
}

QueryWeapon4(piecenum)
{
	piecenum = flare4;
	return (0);
}

AimWeapon5(heading, pitch)
{
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	if(canshoot == 0)												//Checks if it needs to shoot at a target
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	Signal SIG_AIM_5;
	set-signal-mask SIG_AIM_5;
	while(NOT (weapon == 4))										//Waits for its turn
	{
		sleep 1;
	}
	return (1);
}

AimFromWeapon5(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon5()
{
	timeout = 1;
	justfired4 = 1;													//Used to delay next opening of hatches, so they close between shots
	canshoot = canshoot - 1;
	start-script Timer();
	missilesfired = missilesfired + 1;
	sleep (burstrate2 - 80);
	weapon = 5;
	sleep (8275 - (burstrate2 - 100));
	justfired4 = 0;
}

QueryWeapon5(piecenum)
{
	piecenum = flare3;
	return (0);
}

AimWeapon6(heading, pitch)
{
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	if(canshoot == 0)												//Checks if it needs to shoot at a target
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	Signal SIG_AIM_6;
	set-signal-mask SIG_AIM_6;
	while(NOT (weapon == 5))										//Waits for its turn
	{
		sleep 1;
	}
	return (1);
}

AimFromWeapon6(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon6()
{
	timeout = 1;
	justfired5 = 1;													//Used to delay next opening of hatches, so they close between shots
	canshoot = canshoot - 1;
	start-script Timer();
	missilesfired = missilesfired + 1;
	sleep (burstrate2 - 80);
	weapon = 6;
	sleep (8275 - (burstrate2 - 100));
	justfired5 = 0;
}

QueryWeapon6(piecenum)
{
	piecenum = flare2;
	return (0);
}

AimWeapon7(heading, pitch)
{
	if( target == 0)												//Doesn't shoot if laser isn't shooting
	{
		return (0);
	}
	if(opened == 0)													//Opens if it isn't already
	{
		start-script Open(0);
	}
	if(canshoot == 0)												//Checks if it needs to shoot at a target
	{
		return (0);
	}
	if(ready == 0)													//Checks if fully open		
	{
		return (0);
	}
	Signal SIG_AIM_7;
	set-signal-mask SIG_AIM_7;
	while(NOT (weapon == 6))										//Waits for its turn
	{
		sleep 1;
	}
	return (1);
}

AimFromWeapon7(piecenum)
{
	piecenum = targetFlare;
}

FireWeapon7()
{
	timeout = 1;
	justfired6 = 1;													//Used to delay next opening of hatches, so they close between shots
	canshoot = canshoot - 1;
	start-script Timer();
	missilesfired = missilesfired + 1;
	sleep (burstrate2 - 80);
	weapon = 1;
	sleep (8275 - (burstrate2 - 100));
	justfired6 = 0;
}

QueryWeapon7(piecenum)
{
	piecenum = flare1;
	return (0);
}

SweetSpot(piecenum)
{
	piecenum = chassis;
}

Killed(severity, corpsetype)
{
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type BITMAPONLY | NOHEATCLOUD;
		//explode flare2 type BITMAPONLY | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode backTracks type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type FALL | NOHEATCLOUD;
		//explode flare2 type FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type SMOKE | FALL | NOHEATCLOUD;
		explode backTracks type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		//explode flare2 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		explode chassis type BITMAPONLY | NOHEATCLOUD;
		explode trackingTower type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		explode backTracks type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rTrack type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode flare1 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		//explode flare2 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
