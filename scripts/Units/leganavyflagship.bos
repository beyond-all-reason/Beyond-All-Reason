
#include "../recoil_common_includes.h"

piece
    wake,
    torus3,
    torus2,
    torus1,
    targetingWeaponPitchPivot,
    targetingWeaponHeadingPivot,
    heatrayRightPitchPivot,
    heatrayRight,
    heatrayPlatingRight,
    heatrayPlatingLeft,
    heatrayLeftPitchPivot,
    heatrayLeft,
    heatrayFlareRight,
    heatrayFlareLeft,
    engineSpurt,
    bow,
    base,
    aimbit,
    frontRailgun1PitchPivot,
    frontRailgun1HeadingPivot,
    frontRailgun1,
    frontRailgun1Rail3,
    frontRailgun1Rail2,
    frontRailgun1Rail1,
    frontRailgun2PitchPivot,
    frontRailgun2HeadingPivot,
    frontRailgun2,
    frontRailgun2Rail3,
    frontRailgun2Rail1,
    frontRailgun2Rail2,
    rearRailgun1PitchPivot,
    rearRailgun1HeadingPivot,
    rearRailgun1,
    rearRailgun1Rail3,
    rearRailgun1Rail2,
    rearRailgun1Rail1,
    rearRailgun2PitchPivot,
    rearRailgun2HeadingPivot,
    rearRailgun2,
    frontRail1TopRight3,
    rearRailgun2Rail1,
    rearRailgun2Rail2,
    frontRailgun1Flare,
    frontRailgun2Flare,
    rearRailgun1Flare,
    rearRailgun2Flare
;


static-var
    rightGun1WhichBarrel,
    rightGun2WhichBarrel,
    rightGun3WhichBarrel,
    leftGun1WhichBarrel,
    leftGun2WhichBarrel,
    leftGun3WhichBarrel,
    frontRailgun1WhichBarrel,
    frontRailgun2WhichBarrel,
    rearRailgun1WhichBarrel,
    rearRailgun2WhichBarrel,
    mainTurretHeadingVar,
    restore_delay
;

// Signal definitions
    #define SIGNAL_MOVE 1
    #define SIGNAL_AIM1 4
    #define SIGNAL_AIM2 8
    #define SIGNAL_AIM3 16
    #define SIGNAL_AIM4 32
    #define SIGNAL_AIM5 64
    #define SIGNAL_AIM6 128
    #define SIGNAL_AIM7 256
    #define SIGNAL_AIM8 512
    #define SIGNAL_AIM9 1024
    #define SIGNAL_AIM10 2048
    #define SIGNAL_AIM11 4096
    #define SIGNAL_AIM12 8192
#define SIGNAL_AIM13 16384


#define RB_MASS 60
#define RB_LENGTH 12
#define RB_WIDTH 6
#define RB_PITCH_ACCELERATION 30
#define RB_ROLL_ACCELERATION 8
#define RB_RECOIL_ENERGY_1 100
#define RB_RECOIL_ENERGY_2 100
#define RB_WAKE_PIECE wake
#define RB_WAKE_PIECE2 engineSpurt
#define RB_WAKE_CEG 1024 + 1
#define RB_BOWSPLASH_PIECE bow
#define RB_BOWSPLASH_CEG 1024 + 2
#define RB_IDLE_KICK 3000

#include "../bar_ships_common.h"

//////////////////////////////////////////////////////////////// CREATE FUNCTION

Create()
{
	set ARMORED to 1;

    rightGun1WhichBarrel = 0;
    rightGun2WhichBarrel = 0;
    rightGun3WhichBarrel = 0;
    leftGun1WhichBarrel = 0;
    leftGun2WhichBarrel = 0;
    leftGun3WhichBarrel = 0;
    frontRailgun1WhichBarrel = 0;
    frontRailgun2WhichBarrel = 0;
    rearRailgun1WhichBarrel = 0;
    rearRailgun2WhichBarrel = 0;

	restore_delay = 3000;

    turn rearRailgun1HeadingPivot to y-axis <-180> now;
    turn rearRailgun2HeadingPivot to y-axis <-180> now;

    turn rightGun1 to y-axis <-90> now;
    turn rightGun2 to y-axis <-90> now;
    turn rightGun3 to y-axis <-90> now;

    turn leftGun1 to y-axis <90> now;
    turn leftGun2 to y-axis <90> now;
    turn leftGun3 to y-axis <90> now;

	start-script CATT1_Init();
	start-script InitRockBoat();
	SLEEP_UNTIL_UNITFINISHED;
	start-script BoatPhysics();
}

//////////////////////////////////////////////////////////////// RESTORE FUNCTIONS

SetMaxReloadTime(reloadMS)
{
	restore_delay = reloadMS * 2;
}

static-var  Stunned;
static-var aimy1velocity, aimy1target, aimy1position, gameFrame;

#define AIMY1_RESTORE_SPEED <1.0>
//aiming system restore
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	turn targetingWeaponPitchPivot to x-axis <0.0> speed <45.0>;
	while ( get ABS(aimy1position) > AIMY1_RESTORE_SPEED){
		if (aimy1position > 0 ) {
			aimy1position = aimy1position - AIMY1_RESTORE_SPEED;
			aimy1velocity = (-1) * AIMY1_RESTORE_SPEED;
            sleep 1;
		}
		else
		{
			aimy1position = aimy1position + AIMY1_RESTORE_SPEED;
			aimy1velocity = AIMY1_RESTORE_SPEED;
            sleep 1;
		}
		turn targetingWeaponHeadingPivot to y-axis aimy1position speed 30 * AIMY1_RESTORE_SPEED;
		sleep 30;
	}
	aimy1velocity = 0;
}

// heatray restores
ExecuteRestoreAfterDelayHR1(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting 1st heatray turret heading
}

ExecuteRestoreAfterDelayHR2(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting 2nd heatray turret heading
}

// railgun restores
ExecuteRestoreAfterDelayFRRG(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting front right railgun
}

ExecuteRestoreAfterDelayFLRG(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting front left railgun
}

ExecuteRestoreAfterDelayRRRG(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting rear right railgun
}

ExecuteRestoreAfterDelayRLRG(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting rear left railgun
}

//machine gun restores
ExecuteRestoreAfterDelayRG1(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting right gun 1
}

ExecuteRestoreAfterDelayRG2(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting right gun 2
}

ExecuteRestoreAfterDelayRG3(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting right gun 3
}

ExecuteRestoreAfterDelayLG1(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting left gun 1
}

ExecuteRestoreAfterDelayLG2(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting left gun 2
}

ExecuteRestoreAfterDelayLG3(){
    if (Stunned) {
        return (1);
    }
    sleep 1;
    //code for resting left gun 3
}

SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
        start-script ExecuteRestoreAfterDelayHR1();
        start-script ExecuteRestoreAfterDelayHR2();
        start-script ExecuteRestoreAfterDelayFRRG();
        start-script ExecuteRestoreAfterDelayFLRG();
        start-script ExecuteRestoreAfterDelayRRRG();
        start-script ExecuteRestoreAfterDelayRLRG();
        start-script ExecuteRestoreAfterDelayRG1();
        start-script ExecuteRestoreAfterDelayRG2();
        start-script ExecuteRestoreAfterDelayRG3();
        start-script ExecuteRestoreAfterDelayLG1();
        start-script ExecuteRestoreAfterDelayLG2();
        start-script ExecuteRestoreAfterDelayLG3();
	}
}
RestoreAfterDelay()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}
RestoreAfterDelayHR1()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayHR1();
}
RestoreAfterDelayHR2()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayHR2();
}
RestoreAfterDelayFRRG()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayFRRG();
}
RestoreAfterDelayFLRG()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayFLRG();
}
RestoreAfterDelayRRRG()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayRRRG();
}
RestoreAfterDelayRLRG()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayRLRG();
}
RestoreAfterDelayRG1()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayRG1();
}
RestoreAfterDelayRG2()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayRG2();
}
RestoreAfterDelayRG3()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayRG3();
}
RestoreAfterDelayLG1()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayLG1();
}
RestoreAfterDelayLG2()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayLG2();
}
RestoreAfterDelayLG3()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelayLG3();
}

waveSplash()
{
	while( TRUE )
	{
		turn base to x-axis <-1.0> speed <1.0>;
		move base to y-axis [0.23] speed [0.17];
		wait-for-turn base around x-axis;
		turn base to x-axis <0.0> speed <1.0>;
		move base to y-axis [0.0] speed [0.17];
		wait-for-turn base around x-axis;
        sleep 1;
	}
}

StartMoving(reversing)
{

}

StopMoving()
{

}

//////////////////////////////////////////////////////////////// WEAPON FUNCTIONS

//targeting system
AimFromWeapon1(pieceIndex)
{
	pieceIndex = targetingWeaponHeadingPivot;
}

QueryWeapon1(pieceIndex)
{
	pieceIndex = torus3;
}


//-------------------------------CONSTANT ACCELERATION TURRET TURNING---------------------------
// MaxVelocity and acceleration are in degrees per frame (not second!)
// Jerk is the minimum velocity of the turret
// A high precision requirement can result in overshoots if desired 
// Author Beherith mysterme@gmail.com. License: GNU GPL v2.

#define CATT1_PIECE_Y targetingWeaponHeadingPivot

#define CATT1_MAX_VELOCITY <3.0>
#define CATT1_ACCELERATION <0.12>
#define CATT1_JERK <0.5>
#define CATT1_PRECISION <1.2>
#define CATT1_RESTORE_SPEED <1.0>
#define CATT1_PITCH_SPEED <45>

#include "../constant_acceleration_turret_turning_1.h"



// #define SIGNAL_AIM1 256
AimWeapon1(heading, pitch)
{
	signal SIGNAL_AIM1;
	set-signal-mask SIGNAL_AIM1;
	mainTurretHeadingVar = heading;
	//We can do this any time
	//turn targetingWeaponPitchPivot to x-axis RB_AIMPITCHCORRECTION(heading) - pitch speed <25.0>;
	
	call-script CATT1_Aim(heading,pitch);
	return (1);
}

// FireWeapon1()
// {
// 	RB_RECOILBOAT(aimDir1, RB_RECOIL_ENERGY_1);
// }


// right heatray
AimFromWeapon2(pieceIndex)
{
	pieceIndex = heatrayRightPitchPivot;
}

QueryWeapon2(pieceIndex)
{
	pieceIndex = heatrayFlareRight;
}

AimWeapon2(heading, pitch)
{
	signal SIGNAL_AIM2;
	set-signal-mask SIGNAL_AIM2;
    //wait-for-turn targetingWeaponHeadingPivot around y-axis;
    turn heatrayRightPitchPivot to y-axis heading - mainTurretHeadingVar speed <6>;
    turn targetingWeaponPitchPivot to x-axis RB_AIMPITCHCORRECTION(heading) - pitch speed <25.0>;
    //wait-for-turn heatrayRightPitchPivot around y-axis;
    //wait-for-turn targetingWeaponPitchPivot around x-axis;
	start-script RestoreAfterDelayHR1();
	return (1);
}

FireWeapon2()
{

}

// left heatray
AimFromWeapon3(pieceIndex)
{
	pieceIndex = heatrayLeftPitchPivot;
}

QueryWeapon3(pieceIndex)
{
	pieceIndex = heatrayFlareLeft;
}

AimWeapon3(heading, pitch)
{
	signal SIGNAL_AIM3;
	set-signal-mask SIGNAL_AIM3;
    // wait-for-turn targetingWeaponHeadingPivot around y-axis;
    turn heatrayLeftPitchPivot to y-axis heading - mainTurretHeadingVar speed <6>;
    turn targetingWeaponPitchPivot to x-axis RB_AIMPITCHCORRECTION(heading) - pitch speed <25.0>;
    // wait-for-turn targetingWeaponHeadingPivot around y-axis;
    //wait-for-turn heatrayLeftPitchPivot around y-axis;
    //wait-for-turn targetingWeaponPitchPivot around x-axis;
	start-script RestoreAfterDelayHR2();
	return (1);
}

FireWeapon3()
{

}

//front right railgun
AimFromWeapon4(pieceIndex)
{
	pieceIndex = frontRailgun1;
}

QueryWeapon4(pieceIndex)
{
	pieceIndex = frontRailgun1Flare;
}

AimWeapon4(heading, pitch)
{
	signal SIGNAL_AIM4;
	set-signal-mask SIGNAL_AIM4;

    if (heading < <15> AND heading > <-165>){
        turn frontRailgun1HeadingPivot to y-axis heading speed <150.0>;
        turn frontRailgun1PitchPivot to x-axis (-1 * pitch) speed <15.0>;
        wait-for-turn frontRailgun1HeadingPivot around y-axis;
        wait-for-turn frontRailgun1PitchPivot around x-axis;
        start-script RestoreAfterDelayFRRG();
        return (1);
    }
    else{
        return (0);
    }
}

FireWeapon4()
{

}

//front left railgun
AimFromWeapon5(pieceIndex)
{
	pieceIndex = frontRailgun2;
}

QueryWeapon5(pieceIndex)
{
	pieceIndex = frontRailgun2Flare;
}

AimWeapon5(heading, pitch)
{
	signal SIGNAL_AIM5;
	set-signal-mask SIGNAL_AIM5;

    if (heading > <-15> AND heading < <165>){
        turn frontRailgun2HeadingPivot to y-axis heading speed <150.0>;
        turn frontRailgun2PitchPivot to x-axis (-1 * pitch) speed <15.0>;
        wait-for-turn frontRailgun2HeadingPivot around y-axis;
        wait-for-turn frontRailgun2PitchPivot around x-axis;
        start-script RestoreAfterDelayFLRG();
        return (1);
    }
    else{
        return (0);
    }
}

FireWeapon5()
{

}

//rear right railgun
AimFromWeapon6(pieceIndex)
{
	pieceIndex = rearRailgun1;
}

QueryWeapon6(pieceIndex)
{
	pieceIndex = rearRailgun1Flare;
}

AimWeapon6(heading, pitch)
{
	signal SIGNAL_AIM6;
	set-signal-mask SIGNAL_AIM6;
	if(heading > <-10> AND heading < <165>)
	{
		return (0);
	}
	turn rearRailgun1HeadingPivot to y-axis heading speed <150.0>;
    turn rearRailgun1PitchPivot to x-axis (-1 * pitch) speed <15.0>;
	wait-for-turn rearRailgun1HeadingPivot around y-axis;
    wait-for-turn rearRailgun1PitchPivot around x-axis;
	start-script RestoreAfterDelayRRRG();
	return (1);
}

FireWeapon6()
{

}

//rear left railgun
AimFromWeapon7(pieceIndex)
{
	pieceIndex = rearRailgun2;
}

QueryWeapon7(pieceIndex)
{
	pieceIndex = rearRailgun2Flare;
}

AimWeapon7(heading, pitch)
{
	signal SIGNAL_AIM7;
	set-signal-mask SIGNAL_AIM7;
	if(heading < <10> AND heading > <-165>)
	{
		return (0);
	}
	turn rearRailgun2HeadingPivot to y-axis heading speed <150.0>;
    turn rearRailgun2PitchPivot to x-axis (-1 * pitch) speed <15.0>;
	wait-for-turn rearRailgun2HeadingPivot around y-axis;
    wait-for-turn rearRailgun2PitchPivot around x-axis;
	start-script RestoreAfterDelayRLRG();
	return (1);
}

FireWeapon7()
{

}


Killed(severity, corpsetype)
{
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		// explode base type BITMAPONLY | NOHEATCLOUD;
		// explode tur4 type BITMAPONLY | NOHEATCLOUD;
		// explode sleeves4 type BITMAPONLY | NOHEATCLOUD;
		// explode flare4a type BITMAPONLY | NOHEATCLOUD;
		// explode flare4b type BITMAPONLY | NOHEATCLOUD;
		// explode tur3 type BITMAPONLY | NOHEATCLOUD;
		// explode sleeves3 type BITMAPONLY | NOHEATCLOUD;
		// explode flare3a type BITMAPONLY | NOHEATCLOUD;
		// explode flare3b type BITMAPONLY | NOHEATCLOUD;
		// explode tur6 type BITMAPONLY | NOHEATCLOUD;
		// explode sleeves6 type BITMAPONLY | NOHEATCLOUD;
		// explode gun6 type BITMAPONLY | NOHEATCLOUD;
		// explode barrel6 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		// explode base type BITMAPONLY | NOHEATCLOUD;
		// explode tur4 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves4 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode flare4a type FALL | NOHEATCLOUD;
		// explode flare4b type FALL | NOHEATCLOUD;
		// explode tur3 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves3 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode flare3a type FALL | NOHEATCLOUD;
		// explode flare3b type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode tur6 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves6 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode gun6 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode barrel6 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		// explode base type BITMAPONLY | NOHEATCLOUD;
		// explode tur4 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves4 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode flare4a type SMOKE | FALL | NOHEATCLOUD;
		// explode flare4b type SMOKE | FALL | NOHEATCLOUD;
		// explode tur3 type SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves3 type SMOKE | FALL | NOHEATCLOUD;
		// explode flare3a type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		// explode flare3b type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode tur6 type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves6 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode gun6 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode barrel6 type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		// explode base type BITMAPONLY | NOHEATCLOUD;
		// explode tur4 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves4 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode flare4a type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		// explode flare4b type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		// explode tur3 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode sleeves3 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode flare3a type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		// explode flare3b type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		// explode tur6 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		// explode sleeves6 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		// explode gun6 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		// explode barrel6 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
