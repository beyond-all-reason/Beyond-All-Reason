
#include "../../recoil_common_includes.h"

piece  base, flare, turret, sleeve, barrel, smoke1, smoke2, lflare, rflare, lball, rball, lbarrel, rbarrel, flag;

static-var  restore_delay, last_lball_heading, last_rball_heading, willlaughing, islaughing, waslaughing, lastfired, healthperc;

// Signal definitions
#define SIGNAL_AIM1 256
#define SIGNAL_MOVE 1
#define SIGNAL_AIM2 512
#define SIGNAL_AIM3	1024
#define SIGNAL_TICKLE 32


#define VD_PIECE1 smoke1
#define VD_PIECE2 smoke2
#define VD_AMPHIBIOUS
#define VD_DIRTCEG 1024 + 1
#include "../../vehicle_dirt_cegs.h"

#define BASEPIECE base
#define HITSPEED <25.0>
//how 'heavy' the unit is, on a scale of 1-10
#define UNITSIZE 10
#define MAXTILT 100
#define RECOIL_POWER 50000
#include "../../unit_hitbyweaponid_and_smoke.h"


startLaughing (){
	if (willlaughing==0) {
		willlaughing = 1;
		
		//animate flag in
		show flag;
		move flag to y-axis [44] speed [200.0];//start is 14 abs, 0 rel...
		sleep 1000;
		willlaughing=0;
		islaughing=1;
	}
	start-script tickle();
}
stopLaughing (){
	if (islaughing==1 AND waslaughing==0) {
		islaughing = 0;
		waslaughing = 1;
		
		//animate flag out
		move flag to y-axis [0] speed [200.0];//start is 14 abs, 0 rel...
		sleep 1000;		
		hide flag;
		
		start-script reset_waslaughing();
	}
}

//tickled logic, rolling 10s reset every light damage, cancel the reset if more happens

tickle() {
	signal SIGNAL_TICKLE;
	set-signal-mask SIGNAL_TICKLE;
	sleep 10000;
	start-script stopLaughing();
}

//these might need signals?
reset_willlaughing(){
		sleep 5000;
		willlaughing=0;
}
reset_waslaughing(){
		sleep 5000;
		waslaughing=0;
}

Create()
{
	hide flare;
	hide smoke1;
	hide smoke2;
	lastfired = 0;
	hide flag;
	restore_delay = 3000;
	last_lball_heading = -1000000;
	last_rball_heading = -1000000;
	willlaughing=0;
	islaughing=0;
	waslaughing=0;
}

StartMoving(reversing)
{
	signal SIGNAL_MOVE;
	set-signal-mask SIGNAL_MOVE;
	start-script Vehicle_Dirt_Ceg();
}


StopMoving()
{
	signal SIGNAL_MOVE;
}

SetMaxReloadTime(reloadMS)
{
	restore_delay = reloadMS * 2;
}

static-var  Stunned;
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	turn turret to y-axis <0.0> speed <35.005495>;
	turn sleeve to x-axis <0.0> speed <15.0>;	
	
}

SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
	}
}
RestoreAfterDelay()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}


RestoreAfterDelay_lspon()
{
	set-signal-mask SIGNAL_AIM2; //ensures restore animation is killed if this weapon is aimed
	sleep restore_delay;
	//large negative values to let wait-for-turn happen on first target
	last_lball_heading = -1000000;
	turn lball to y-axis <0> speed <90>;
	turn lbarrel to x-axis <0.0> speed <15>;
}

RestoreAfterDelay_rspon()
{
	set-signal-mask SIGNAL_AIM3; //ensures restore animation is killed if this weapon is aimed
	sleep restore_delay;
	//large negative values to let wait-for-turn happen on first target
	last_rball_heading = -1000000;
	turn rball to y-axis <0> speed <90>;
	turn rbarrel to x-axis <0.0> speed <15>;
}




AimWeapon1(heading, pitch)
{
	signal SIGNAL_AIM1;
	set-signal-mask SIGNAL_AIM1;
	turn turret to y-axis heading speed <40.0>;
	turn sleeve to x-axis <0.0> - pitch speed <45.0>;
	wait-for-turn turret around y-axis;
	wait-for-turn sleeve around x-axis;
	start-script RestoreAfterDelay();
	return (1);//*/
}

FireWeapon1()
{
	lastfired = 1;



	emit-sfx 1024 + 0 from flare;
	move barrel to z-axis [-2.400000] speed [500.0];
	emit-sfx 1024 + 0 from flare;
	wait-for-move barrel along z-axis;
	move barrel to z-axis [0.0] speed [3.0];//*/

}

AimFromWeapon1(pieceIndex)
{
	pieceIndex = turret;
}

QueryWeapon1(pieceIndex)
{
	pieceIndex = flare;
}




//left
AimWeapon2(heading, pitch)
{


	// logic to restrict turret rotation due to unitdef maxangledif
	// maxangledif=180 = 0 to 180 degrees = 0 to 32,768
	// does no turn animation if the target heading is out of firing arc
	// out of firing arc aim calls happen during "preaiming" logic
	if ( (heading<0) )
	{
		return (0);
	}
	signal SIGNAL_AIM2;
	set-signal-mask SIGNAL_AIM2;

	// values in <> are degrees per second
	// otherwise angles are in COB angular unit (cau) - There are 65536 cau in a circle
	// In general, 6 cau per frame ~= 1 degree per second
	turn lball to y-axis heading speed <120>;
	// if weapon will take more than 1 frame to turn to new angle, wait for turn
	if ( (get ABS(last_lball_heading - heading) > 720) )
	{
		// seems to take 3 frames for wait-for-turn to process
		wait-for-turn lball around y-axis;
	}
	last_lball_heading = heading;
	//return (1);	
	//get PRINT(get GAME_FRAME, heading, pitch);

	turn lbarrel to x-axis <0.0> - pitch speed <80.0>;
	wait-for-turn lbarrel around x-axis;
	//get PRINT(321);
	start-script RestoreAfterDelay_lspon();
	return (1);
}

FireWeapon2()
{
	lastfired = 2;
	move lbarrel to z-axis [-1] speed [62.500000];
	wait-for-move lbarrel along z-axis;
	move lbarrel to z-axis [0.0] speed [4.0];
}

AimFromWeapon2(pieceIndex)
{
	pieceIndex = lball;
}

QueryWeapon2(pieceIndex)
{
	pieceIndex = lflare;
}





AimWeapon3(heading, pitch)
{

//get PRINT(heading);
	// logic to restrict turret rotation due to unitdef maxangledif
	// maxangledif=180 = -180 to 0 degrees = -32,768 to 0
	// does no turn animation if the target heading is out of firing arc
	// out of firing arc aim calls happen during "preaiming" logic
	if ( (heading>0) )
	{
		return (0);
	}
	signal SIGNAL_AIM3;
	set-signal-mask SIGNAL_AIM3;
	// values in <> are degrees per second
	// otherwise angles are in COB angular unit (cau) - There are 65536 cau in a circle
	// In general, 6 cau per frame ~= 1 degree per second
	turn rball to y-axis heading speed <120>;
	// if weapon will take more than 1 frame to turn to new angle, wait for turn
	if ( (get ABS(last_rball_heading - heading)>720) )
	{
		// seems to take 3 frames for wait-for-turn to process
		wait-for-turn rball around y-axis;
	}
	last_rball_heading=heading;


	//get PRINT(get GAME_FRAME, heading, pitch);
	turn rbarrel to x-axis <0.0> - pitch speed <80.0>;
	wait-for-turn rbarrel around x-axis;

	
	start-script RestoreAfterDelay_rspon();
	return (1);
}	
	
	


FireWeapon3()
{
	lastfired=3;
	move rbarrel to z-axis [-1] speed [62.500000];
	wait-for-move rbarrel along z-axis;
	move rbarrel to z-axis [0.0] speed [4.0];
}

AimFromWeapon3(pieceIndex)
{
	pieceIndex = rball;
}

QueryWeapon3(pieceIndex)
{
	pieceIndex = rflare;
}

















Killed(severity, corpsetype)
{
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type BITMAPONLY | NOHEATCLOUD;
		explode sleeve type BITMAPONLY | NOHEATCLOUD;
		explode barrel type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lbarrel type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rbarrel type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel type FALL | NOHEATCLOUD;
		explode lbarrel type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rbarrel type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lball type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rball type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type SMOKE | FALL | NOHEATCLOUD;
		explode barrel type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lbarrel type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rbarrel type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode lball type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode rball type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
